# Java 内存模型



## 原子性

原子性是指**操作是不可分的**，要么全部一起执行，要么不执行。在 java 中，其表现在对于共享变量的某些操作，是不可分的，必须连续的完成。比如 a++，对于共享变量a的操作，实际上会执行3个步骤：

1.读取变量a的值，假如a=1
2.a的值+1，为2
3.将2值赋值给变量a，此时a的值应该为2

这三个操作中任意一个操作，a的值如果被其他线程篡改了，那么都会出现我们不希望出现的结果。所以必须保证这3个操作是原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在上面的过程中出现其他线程修改了a的值，在满足原子性的原则下，上面的操作应该失败。

java中实现原子操作的方法大致有2种：**锁机制**、**无锁CAS机制**

## 可见性

**可见性是指一个线程对共享变量的修改，对于另一个线程来说是否是可以看到的。**

为什么会出现这种问题呢？看一下java线程内存模型：
![image-20241120215721943](./assets/image-20241120215721943.png)

- 我们定义的所有变量都储存在 `主内存` 中
- 每个线程都有自己 `独立的工作内存` ，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）
- 线程对共享变量所有的操作都必须在自己的工作内存中进行，不能直接从主内存中读写（不能越级）
- 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行。（同级相互独立不能相互访问）



线程需要修改一个共享变量 X ，需要先把X从主内存复制一份到线程的工作内存，在自己的工作内存中修改完毕之后，再从工作内存中回写到主内存。
如果线程对变量的操作没有刷写回主内存的话，仅仅改变了自己的工作内存的变量的副本，那么对于其他线程来说是不可见的。
而如果另一个变量没有读取主内存中的新的值，而是使用旧的值的话，同样的也可以列为不可见。

**共享变量可见性的实现原理：**

线程A对共享变量的修改要被线程B及时看到的话，需要进过以下步骤：

1. 线程A在自己的工作内存中修改变量之后，需要将变量的值刷新到主内存中
2. 线程B要把主内存中变量的值更新到工作内存中

关于线程可见性的控制，可以使用**volatile**、**synchronized**、**锁**来实现

## 有序性

有序性指的是程序按照代码的先后顺序执行。

为了性能优化，编译器和处理器会进行指令冲排序，有时候会改变程序语句的先后顺序，比如：

```java
int a = 1;  //1
int b = 20; //2
int c = a + b; //3
```

编译器优化后可能变成:

```java
int b = 20;  //1
int a = 1; //2
int c = a + b; //3
```

上面这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。

在单例模式的实现上有一种双重检验锁定的方式，代码如下：

```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```

我们先看`instance = new Singleton();`

**未被编译器优化的操作：**

1. 指令1：分配一款内存M
2. 指令2：在内存M上初始化Singleton对象
3. 指令3：将M的地址赋值给instance变量

**编译器优化后的操作指令：**

1. 指令1：分配一块内存M
2. 指令2：将M的地址赋值给instance变量
3. 指令3：在内存M上初始化Singleton对象

现在有2个线程，刚好执行的代码被编译器优化过，过程如下：

![image-20241120215129147](./assets/image-20241120215129147.png)

最终线程B获取的instance是没有初始化的，此时去使用instance可能会产生一些意想不到的错误。

现在比较好的做法就是采用静态内部内的方式实现：

```java
public class SingletonDemo {
    private SingletonDemo() {
    }
    private static class SingletonDemoHandler{
        private static SingletonDemo instance = new SingletonDemo();
    }
    public static SingletonDemo getInstance() {
        return SingletonDemoHandler.instance;
    }
}
```



